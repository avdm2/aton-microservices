## Дмитриев Артем Вадимович, тестовое задание на позицию стажера-разработчика в компанию Aton. Команда корпоративной шины данных и микосервисов

### Примечание
- Для удобства я решил оставить все необходимые классы в одном пакете **ru.aton**.
- Для хранимой сущности используется **Lombok**, чтобы уменьшить количество кода.

### Объяснение выбора алгоритма
Основная структура данных, используемая для данного решения - **HashMap**. 
В зависимости от количества полей сущности (не считая номера аккаунта) будет зависеть количество словарей в кеше. 
Учитывая, что задание выполняется на **Java 17**, данное решение будет оптимальным, так как вырождение словаря в связный 
список при многих коллизиях не произойдет, вместо этого будет использоваться красно-черное дерево, временная сложность 
операций в котором в худшем случае **O(log(n))**, как и требуется по условию, а не **O(n)**. 

Если учесть, что кеш требуется реализовать используя Java ниже 8 версии, то можно использовать **TreeMap** для 
хранения сущностей по полю, уникальность которого мы не можем гарантировать, однако в данном случае
решение было бы менее эффективным по памяти, поскольку узлы красно-черного дерева требуют хранить ссылки на родителя и 
детей, а также и на цвет, что увеличивает занимаемую память. В случае же с **HashMap** необходимость использования 
красно-черного дерева появляется только в случае коллизий, что позволяет снизить потребление памяти.

Для более эффективного подхода я решил использовать три (в данном случае) словаря:
- Первый словарь: [номер аккаунта, аккаунт].
- Второй словарь: [значение поля name, сет номеров аккаунта с тем же значением name].
- Третий словарь: [значение поля value, сет номеров аккаунта с тем же значением value].

Данный подход позволяет сократить занимаемую память и не хранить во всех словарях целые сущности. 
Можно создать один словарь, в котором они будут содержаться.
Ключом в данном случае обязательно должно выступать поле, уникальность которого мы гарантируем, чтобы избежать коллизий.
Вместо списков используются сеты для поддержания эффективности по памяти.